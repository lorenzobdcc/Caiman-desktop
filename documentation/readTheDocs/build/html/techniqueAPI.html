<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Recherche" href="search.html" /><link rel="next" title="Logbook" href="logbook.html" /><link rel="prev" title="Description technique: Site web" href="techniqueWeb.html" />

    <meta name="generator" content="sphinx-3.5.4, furo 2021.04.11.beta34"/>
        <title>Description technique: API - Documentation Caiman 1.1.0</title>
      <link rel="stylesheet" href="_static/styles/furo.css?digest=59ab60ac09ea94ccfe6deddff6d715cce948a6fc">
    <link rel="stylesheet" href="_static/pygments.css">
    <link media="(prefers-color-scheme: dark)" rel="stylesheet" href="_static/pygments_dark.css">
    


<style>
  :root {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media (prefers-color-scheme: dark) {
    :root {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
  }

  /* For allowing end-user-specific overrides */
  .override-light {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  .override-dark {
    --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
  }
</style><link rel="stylesheet" href="_static/styles/furo-extensions.css?digest=d391b54134226e4196576da3bdb6dddb7e05ba2b"></head>
  <body dir="">
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke-width="1.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z"/>
      <line x1="4" y1="6" x2="20" y2="6" />
      <line x1="10" y1="12" x2="20" y2="12" />
      <line x1="6" y1="18" x2="20" y2="18" />
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
      class="feather feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
      class="feather feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">Documentation Caiman 1.1.0</div></a>
    </div>
    <div class="header-right">
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
  
  
  <span class="sidebar-brand-text">Documentation Caiman 1.1.0</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html">
  <input class="sidebar-search" placeholder=Recherche name="q">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption"><span class="caption-text">table des matières</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="resume.html">Résumé</a></li>
<li class="toctree-l1"><a class="reference internal" href="resume.html#abstract">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="resume.html#remerciement">Remerciement</a></li>
<li class="toctree-l1"><a class="reference internal" href="resume.html#legalite-du-projet">Légalité du projet</a></li>
<li class="toctree-l1"><a class="reference internal" href="resume.html#installation-de-caiman-utilisateur">Installation de Caiman utilisateur</a></li>
<li class="toctree-l1"><a class="reference internal" href="resume.html#installation-de-caiman-serveur">Installation de Caiman serveur</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="cdc.html">Cahier des charges</a></li>
<li class="toctree-l1"><a class="reference internal" href="opportunite.html">Étude d’opportunité</a></li>
<li class="toctree-l1"><a class="reference internal" href="fonctionnelleBDD.html">Analyse fonctionnelle</a></li>
<li class="toctree-l1"><a class="reference internal" href="fonctionnelleWeb.html">Site web Caiman</a></li>
<li class="toctree-l1"><a class="reference internal" href="fonctionnelleAPI.html">API Caiman</a></li>
<li class="toctree-l1"><a class="reference internal" href="fonctionnelleC%23.html">Application  Caiman C#</a></li>
<li class="toctree-l1"><a class="reference internal" href="fonctionnelleInterface.html">Interface utilisateur utilisable à la manette</a></li>
<li class="toctree-l1"><a class="reference internal" href="debian.html">Serveur Debian 10</a></li>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">Analyse organique</a></li>
<li class="toctree-l1"><a class="reference internal" href="techniqueWeb.html">Description technique: Site web</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Description technique: API</a></li>
<li class="toctree-l1"><a class="reference internal" href="logbook.html">Logbook</a></li>
</ul>

</div>
</div>
      </div>
      
    </div>
  </aside>
  <main class="main">
    <div class="content">
      <article role="main">
        <label class="toc-overlay-icon toc-content-icon" for="__toc">
          <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
        </label>
        <div class="section" id="description-technique-api">
<h1>Description technique: API<a class="headerlink" href="#description-technique-api" title="Lien permanent vers ce titre">¶</a></h1>
<div class="section" id="telechargement-de-jeu">
<h2>Téléchargement de jeu<a class="headerlink" href="#telechargement-de-jeu" title="Lien permanent vers ce titre">¶</a></h2>
<p>Les jeux sont sous forme de fichier .iso dans le dossier “caimanWeb\games\”.Par contre, ce n’est pas tout pour simplifier, il faut bien séparer les jeux des différentes consoles. J’ai décidé de créer des dossiers par émulateurs. C’est pourquoi il va y avoir des sous-dossiers “GamecubeWii\” et “Playstation2\”. Chaque jeu est stocké avec le nom que l’administrateur lui aura donné quand il l’a ajouté depuis le site web.</p>
<p>Le chemin sur le serveur web pour accéder au fichier des jeux n’est pas public. Par conséquent, il a donc fallu que je trouve une solution pour que n’importe qui ne puisse pas télécharger un jeu. Pour ce faire, j’ai créé une route dans mon API qui prend en paramètres l’id du jeu et l’apiKey de l’utilisateur qui veut télécharger le jeu.</p>
<p>La fonction getURL(idGame,apiKey) permet de recevoir le lien de téléchargement pour un jeu. Avant de valider le téléchargement, l’API vérifie que l’apiKey qui lui a été donné est valide. Pour savoir si l’apiKey est valide, j’utilise la fonction DAOUser-&gt;Find(apikey) qui me retourne l’utilisateur en lien avec cette apiKey. Si l’apiKey est valide, je vais donc devoir reconstituer le chemin vers le dossier ou est le jeu stocké.</p>
<p>Pour connaître le nom du dossier où se trouve le fichier, il faut savoir de quelle console est le jeu. Pour connaître cette information, je dois rechercher un jeu grâce à son id. Quand j’ai l’id de la console en lien avec le jeu, je dois encore faire une recherche pour savoir quel est son nom de dossier dans la base de données. Alors j’utilise la fonction DAOConsole-&gt;find(idConsole) pour connaître son nom de dossier.</p>
<p>Désormais que nous avons le dossier dans lequel se trouve le fichier du jeu, il faut maintenant connaître son nom de fichier. Pour cela, j’utilise la fonction DAOFile-&gt;find(file). l’id du fichier est connu grâce à l’appel la fonction DAOGame-&gt;find().</p>
<p>Â présent que nous avons toutes les parties du chemin, il est possible de construire le chemin complet en concaténant toutes les parties. Ensuite pour renvoyer le jeu à l’utilisateur, j’utilise les fonctions fopen(path,’rb’) et fpassthru(fopen).</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="x">public function getURL(int $idGame, string $apikey)</span>
<span class="x">    {</span>

<span class="x">        $user = $this-&gt;DAOUser-&gt;find($apikey);</span>
<span class="x">        $fullpath = "";</span>
<span class="x">        if (is_null($user)) {</span>
<span class="x">            return ResponseController::notFoundResponse();</span>
<span class="x">        } else {</span>
<span class="x">            $game = $this-&gt;DAOGame-&gt;find($idGame);</span>
<span class="x">            $file = $this-&gt;DAOFile-&gt;find($game-&gt;idFile);</span>
<span class="x">            $console = $this-&gt;DAOConsole-&gt;find($game-&gt;idConsole);</span>
<span class="x">            $fullpath = "../../../../caimanWeb/games/" . $console-&gt;folderName . "/" . $file-&gt;filename;</span>


<span class="x">            if (file_exists($fullpath)) {</span>
<span class="x">                header('Content-Description: File Transfer');</span>
<span class="x">                header('Content-Type: application/octet-stream');</span>
<span class="x">                header('Content-Disposition: attachment; filename=' . basename($fullpath));</span>
<span class="x">                header('Content-Transfer-Encoding: binary');</span>
<span class="x">                header('Expires: 0');</span>
<span class="x">                header('Cache-Control: must-revalidate, post-check=0, pre-check=0');</span>
<span class="x">                header('Pragma: public');</span>
<span class="x">                header('Content-Length: ' . filesize($fullpath));</span>
<span class="x">                $fp = fopen($fullpath, 'rb');</span>
<span class="x">                fpassthru($fp);</span>
<span class="x">                exit;</span>
<span class="x">            }</span>
<span class="x">        }</span>

<span class="x">        return ResponseController::successfulRequest($fullpath);</span>
<span class="x">    }</span>
</pre></div>
</div>
</div>
<div class="section" id="telechargement-de-sauvegarde">
<h2>Téléchargement de sauvegarde<a class="headerlink" href="#telechargement-de-sauvegarde" title="Lien permanent vers ce titre">¶</a></h2>
<p>Les sauvegardes des utilisateurs sont stockées sous forme de fichiers .zip. L’intérêt d’utiliser des fichiers .zip est la taille et le fait qu’un fichier puisse contenir toutes les sauvegardes instantanément. Les fichiers de sauvegardes se trouvent dans le dossier “\CaimanWeb\saves\”.</p>
<p>Le nom attribué au fichier est décidé au premier envoie de sauvegardes, le nom est le md5 du microtime de l’heure d’envoie.</p>
<p>Pour recevoir le fichier, l’API possède une route qui prend les paramètres suivants:</p>
<ul class="simple">
<li><p>idEmulator</p></li>
<li><p>iduser</p></li>
<li><p>apikey</p></li>
</ul>
<p>Cette route va envoyer le fichier demandé. Comme pour les fichiers des jeux, les sauvegardes sont dans un dossier privé du serveur. La fonction getURLsave( idEmulator, Iduser,apikey) se charge de renvoyer les fichiers à l’utilisateur. Pour faire ça il faut connaître le nom du fichier qui doit être envoyé. Il faut donc utiliser la fonction DAOFileSave-&gt;find( idemulator, idUser) pour connaître les informations du fichier.</p>
<p>Désormais que le nom du fichier est connu, il est possible de retourner le fichier grâce à la fonction fopen(path,’rb’) et fpassthru(fopen) pour renvoyer le fichier à l’utilisateur.</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="x">public function getURLSave(int $idEmulator, int $idUser, string $apikey)</span>
<span class="x">    {</span>

<span class="x">        $user = $this-&gt;DAOUser-&gt;find($apikey);</span>
<span class="x">        $fullpath = "";</span>
<span class="x">        if (is_null($user)) {</span>
<span class="x">            return ResponseController::notFoundResponse();</span>
<span class="x">        } else {</span>
<span class="x">            $fileSave = $this-&gt;DAOFileSave-&gt;find($idEmulator, $idUser);</span>

<span class="x">            if (is_null($fileSave)) {</span>
<span class="x">                return ResponseController::notFoundResponse();</span>
<span class="x">                exit;</span>
<span class="x">            }</span>
<span class="x">            $file = $this-&gt;DAOFile-&gt;find($fileSave-&gt;idFile);</span>
<span class="x">            $fullpath = "../../../../caimanWeb/saves/" . $file-&gt;filename;</span>


<span class="x">            if (file_exists($fullpath)) {</span>
<span class="x">                header('Content-Description: File Transfer');</span>
<span class="x">                header('Content-Type: application/zip');</span>
<span class="x">                header('Content-Disposition: attachment; filename=' . basename($fullpath));</span>
<span class="x">                header('Content-Transfer-Encoding: binary');</span>
<span class="x">                header('Expires: 0');</span>
<span class="x">                header('Cache-Control: must-revalidate, post-check=0, pre-check=0');</span>
<span class="x">                header('Pragma: public');</span>
<span class="x">                header('Content-Length: ' . filesize($fullpath));</span>
<span class="x">                $fp = fopen($fullpath, 'rb');</span>
<span class="x">                fpassthru($fp);</span>
<span class="x">                exit;</span>
<span class="x">            }</span>
<span class="x">        }</span>

<span class="x">        return ResponseController::successfulRequest();</span>
<span class="x">    }</span>
</pre></div>
</div>
<p>Dans l’état actuel de l’applicationCaiman, il est impossible de télécharger seulement la sauvegarde d’un seul jeu, la structure des sauvegardes des émulateurs ne laisse pas vraiment le choix.</p>
</div>
<div class="section" id="upload-de-sauvegarde">
<h2>Upload de sauvegarde<a class="headerlink" href="#upload-de-sauvegarde" title="Lien permanent vers ce titre">¶</a></h2>
<p>Pour enregistrer les sauvegardes, il y a une route dans l’API qui prend en paramètres:</p>
<ul class="simple">
<li><p>idEmulator</p></li>
<li><p>iduser</p></li>
<li><p>apikey</p></li>
<li><p>file</p></li>
</ul>
<p>Les fichiers de sauvegarde concernent un émulateur àchaque fois, donc il faut le spécifier à l’envoi. Il faut aussi spécifier l’utilisateur à qui appartiennent ces sauvegardes, il faut aussi transmettre une apiKey valide et finalement le fichier à envoyer.</p>
<p>Quand l’API reçoit ces informations, il faut déjà vérifier si l’apiKey reçu est bien valide. Si elle est valide, il faut ensuite vérifier si l’utilisateur a déjà créé une sauvegarde pour cet émulateur. Pour effectuer cette vérification, il faut utiliser la fonction DAOFileSave-&gt;find(idEmulator,idUser) qui retourne les informations du fichier s’il existe.</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="x">public function AddSave($idEmulator, $idUser, $apiKey, $file)</span>
<span class="x">    {</span>

<span class="x">        if (is_null($idEmulator) || is_null($idUser) || is_null($apiKey)) {</span>
<span class="x">            return ResponseController::notFoundResponse();</span>
<span class="x">            exit;</span>
<span class="x">        }</span>
<span class="x">        $user = $this-&gt;DAOUser-&gt;find($apiKey);</span>

<span class="x">        if ($user == null) {</span>
<span class="x">            return ResponseController::notFoundResponse();</span>
<span class="x">            exit;</span>
<span class="x">        }</span>
<span class="x">        $isNewFile = false;</span>
<span class="x">        $newfilename = $this-&gt;DAOFileSave-&gt;FindFileName($idEmulator, $idUser);</span>

<span class="x">        if ($newfilename == null) {</span>
<span class="x">            $newfilename = md5(microtime());</span>
<span class="x">            $newfilename = $newfilename . ".zip";</span>
<span class="x">            $isNewFile = true;</span>
<span class="x">        }</span>
<span class="x">        $target_dir = "../../../../caimanWeb/saves/";</span>

<span class="x">        if (move_uploaded_file($file, $target_dir . $newfilename)) {</span>
<span class="x">            if ($isNewFile) {</span>
<span class="x">                $this-&gt;DAOFileSave-&gt;AddFileSave($idEmulator, $idUser, $newfilename);</span>
<span class="x">            }</span>
<span class="x">        } else {</span>
<span class="x">            return ResponseController::uploadFailed();</span>
<span class="x">            exit;</span>
<span class="x">        }</span>

<span class="x">        return ResponseController::successfulRequest();</span>
<span class="x">    }</span>
</pre></div>
</div>
<div class="section" id="sauvegarde-deja-presente">
<h3>Sauvegarde déjà présente<a class="headerlink" href="#sauvegarde-deja-presente" title="Lien permanent vers ce titre">¶</a></h3>
<p>Si la sauvegarde d’un émulateur est déjà présente, il faut utiliser la fonction move_uploaded_file(file,target_dir). Tout d’abord il faut connaître le nom du fichier qui est attribué à la sauvegarde. Pour faire cela, il faut appeler la fonction DAOFileSave-&gt;findFilename(idEmulator,idUser) celle-ci va renvoyer le nom du fichier.Il suffit maintenant d’écraser le fichier présent sur le serveur par le nouveau.</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="x">    public function findFileName(int $idEmulator, int $idUser)</span>
<span class="x">    {</span>

<span class="x">        $statement = "</span>
<span class="x">    SELECT f.filename filesave FROM `filesave` as fs</span>
<span class="x">                LEFT JOIN file as f</span>
<span class="x">                ON fs.idFile = f.id</span>
<span class="x">                WHERE idUser = :ID_user AND idEmulator = :ID_emulator;";</span>
<span class="x">        try {</span>
<span class="x">            $statement = $this-&gt;db-&gt;prepare($statement);</span>
<span class="x">            $statement-&gt;bindParam(':ID_user', $idUser, \PDO::PARAM_INT);</span>
<span class="x">            $statement-&gt;bindParam(':ID_emulator', $idEmulator, \PDO::PARAM_INT);</span>
<span class="x">            $statement-&gt;execute();</span>

<span class="x">            $file = new File();</span>

<span class="x">            if ($statement-&gt;rowCount() == 1) {</span>
<span class="x">                $result = $statement-&gt;fetch(\PDO::FETCH_ASSOC);</span>
<span class="x">                $file-&gt;filename = $result['filesave'];</span>
<span class="x">            }</span>
<span class="x">            return $file-&gt;filename;</span>
<span class="x">        } catch (\PDOException $e) {</span>
<span class="x">            exit($e-&gt;getMessage());</span>
<span class="x">        }</span>
<span class="x">    }</span>
</pre></div>
</div>
</div>
<div class="section" id="sauvegarde-pas-encore-presente">
<h3>Sauvegarde pas encore présente<a class="headerlink" href="#sauvegarde-pas-encore-presente" title="Lien permanent vers ce titre">¶</a></h3>
<p>S’il n’y a aucune sauvegarde pour l’émulateur en question et l’utilisateur en question. Il faut commencer par donner un nom au fichier. Ce nom est constitué du MD5 du microtime() et de l’extension “.zip”. Quand le nom pour le fichier aété créé, il faut uploader le fichier dans le dossier de sauvegarde grâce à la fonction move_uploaded_file(file,path).</p>
<p>Quand l’upload est validé, un ajout de fichier de sauvegarde va se faire grâce à la fonction DAOFileSave-&gt;AddFileSave(idEmulator,idUser,newfilename). Cette fonction va créer une entrée dans la base de données pour le nouveau fichier.</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="x">public function AddFileSave($idEmulator, $idUser, $newFileName)</span>
<span class="x">    {</span>
<span class="x">        $statementFile = "</span>
<span class="x">        INSERT INTO file</span>
<span class="x">        (filename, dateUpdate)</span>
<span class="x">        VALUES</span>
<span class="x">        (:FILENAME, NOW())";</span>
<span class="x">        try {</span>
<span class="x">            $statementFile = $this-&gt;db-&gt;prepare($statementFile);</span>
<span class="x">            $statementFile-&gt;bindParam(':FILENAME', $newFileName, \PDO::PARAM_STR);</span>
<span class="x">            $statementFile-&gt;execute();</span>
<span class="x">            //when create file is done</span>
<span class="x">            $statementFileSave = "</span>
<span class="x">            INSERT INTO filesave</span>
<span class="x">            (idUser, idEmulator,idFile)</span>
<span class="x">            VALUES</span>
<span class="x">            (:ID_user,:ID_emulator, :ID_file)";</span>
<span class="x">            try {</span>
<span class="x">                $statementFileSave = $this-&gt;db-&gt;prepare($statementFileSave);</span>
<span class="x">                $statementFileSave-&gt;bindParam(':ID_user', $idUser, \PDO::PARAM_INT);</span>
<span class="x">                $statementFileSave-&gt;bindParam(':ID_emulator', $idEmulator, \PDO::PARAM_INT);</span>
<span class="x">                $lastInsertId = $this-&gt;db-&gt;lastInsertId();</span>
<span class="x">                $statementFileSave-&gt;bindParam(':ID_file', $lastInsertId, \PDO::PARAM_INT);</span>
<span class="x">                $statementFileSave-&gt;execute();</span>
<span class="x">            } catch (\PDOException $e) {</span>
<span class="x">                exit($e-&gt;getMessage());</span>
<span class="x">            }</span>
<span class="x">        } catch (\PDOException $e) {</span>
<span class="x">            exit($e-&gt;getMessage());</span>
<span class="x">        }</span>
<span class="x">    }</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="mise-a-jour-du-caimantoken">
<h2>Mise à jour du caimanToken<a class="headerlink" href="#mise-a-jour-du-caimantoken" title="Lien permanent vers ce titre">¶</a></h2>
<p>Le caimanToken sert à pouvoir se connecter sans mot de passe à l’application Caiman. Se token doit être changée à chaque fois que l’utilisateur se connecte, que ce soit en se connectant avec un mot de passe ou par le caimanToken justement.</p>
<p>Pour ce faire, j’ai créé une function DAOUser-&gt;updateCaimanToken(apiToken) qui sert à modifier le caimanToken d’un utilisateur dans la base de données. Le caimanToken est un md5 du microtime actuel. Par conséquent, il est presque impossible que deux utilisateurs aient le même.</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="x">public function updateCaimanToken(string $apitocken)</span>
<span class="x">    {</span>
<span class="x">        $statement = "</span>
<span class="x">        UPDATE user</span>
<span class="x">        SET caimanToken = :CAIMAN_TOKEN</span>
<span class="x">        WHERE apitocken = :API_TOCKEN;";</span>

<span class="x">        try {</span>
<span class="x">            $statement = $this-&gt;db-&gt;prepare($statement);</span>
<span class="x">            $statement-&gt;bindParam(':API_TOCKEN', $apitocken);</span>
<span class="x">            $caimanTocken = md5(microtime());</span>
<span class="x">            $statement-&gt;bindParam(':CAIMAN_TOKEN', $caimanTocken);</span>
<span class="x">            $statement-&gt;execute();</span>
<span class="x">        } catch (\PDOException $e) {</span>
<span class="x">            exit($e-&gt;getMessage());</span>
<span class="x">        }</span>
<span class="x">    }</span>
</pre></div>
</div>
</div>
</div>

      </article>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="logbook.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Logbook</div>
              </div>
              <svg><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="techniqueWeb.html">
              <svg><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Description technique: Site web</div>
                
              </div>
            </a>
        </div>

        <div class="related-information">
              Copyright &#169; 2021, Lorenzo Bauduccio
            |
            Built with <a href="https://www.sphinx-doc.org/">Sphinx</a>
              and
              <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
              <a href="https://github.com/pradyunsg/furo">Furo theme</a>.
            |
            <a class="muted-link" href="_sources/techniqueAPI.md.txt"
               rel="nofollow">
              Montrer le code source
            </a>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            Contenu
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Description technique: API</a><ul>
<li><a class="reference internal" href="#telechargement-de-jeu">Téléchargement de jeu</a></li>
<li><a class="reference internal" href="#telechargement-de-sauvegarde">Téléchargement de sauvegarde</a></li>
<li><a class="reference internal" href="#upload-de-sauvegarde">Upload de sauvegarde</a><ul>
<li><a class="reference internal" href="#sauvegarde-deja-presente">Sauvegarde déjà présente</a></li>
<li><a class="reference internal" href="#sauvegarde-pas-encore-presente">Sauvegarde pas encore présente</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mise-a-jour-du-caimantoken">Mise à jour du caimanToken</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </main>
</div>
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/translations.js"></script>
    <script src="_static/scripts/main.js?digest=e931d09b2a40c1bb82b542effe772014573baf67"></script></body>
</html>